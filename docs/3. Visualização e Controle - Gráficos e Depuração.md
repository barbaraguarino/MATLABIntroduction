# Introdução: Vendo e Corrigindo

Nos capítulos anteriores, construímos uma base sólida: aprendemos a criar variáveis e matrizes para armazenar dados e utilizar operações e funções para processá-los. Contundo, o trabalho de um programador ou engenheiro raramente termina ao obter um número ou matriz como resultado. Precisamos de duas capacidades cruciais: primeiro, a habilidade de **interpretar** esses resultados, e a melhor forma de fazer isso é através da visualização gráfica. Segundo, a habilidade de **garantir** que nossos resultados estejam corretos, o que nos leva à arte da depuração (*debugging*).

Este capítulo irá guiá-lo por essas duas áreas. Primeiro, exploramos as poderosas ferramentas de plotagem do MATLAB para transformar dados brutos em gráficos informativos. Em seguida, aprenderemos as técnicas sistemáticas para encontrar e corrigir erros em nossos programas.

# Criação de Diagramas e Gráficos (***Plots*): A Arte de Visualizar Dados**

Uma imagem realmente pode valer mais que mil números. Gráficos nos permite identificar tendências, padrões, anomalias e relações em nossos dados de uma forma que seria quase impossível apenas olhando para uma matriz de números.

## O Comando `plot`: A Ferramenta Essencial para Gráficos 2D

O comando fundamental para a criação de gráficos 2D no MATLAB é a função `plot`. Em sua forma mais básica, a sintaxe é `plot(x,y)`, onde `x` e `y` são dois vetores de **mesmo comprimento**. O vetor `x` contém as coordenadas do eixo horizontal e o vetor `y` contém as coordenadas do eixo vertical. O MATLAB desenha uma linha conectando os pontos definidos por `(x(1), y(1))`, `(x(2), y(2))`, e assim por diante.

Vamos plotar a função seno de $0$ a $2\pi$.

```matlab
% 1. Criar um vetor para o eixo x
% O comando 0:0.1:2*pi cria um vetor que começa em 0, vai até 2*pi,
% com incrementos de 0.1.
x = 0:0.1:2*pi;

% 2. Criar um vetor para o eixo y
% Como x é um vetor, sin(x) será aplicado a cada elemento.
y = sin(x);

% 3. Criar o gráfico
plot(x, y);
```

Ao executar este código, o MATLAB abrirá uma nova janela, chamada “Figure”, contendo o gráfico da função seno.

### Aprimorando a Estética e a Clareza do Gráfico

Um gráfico sem legendas é incompleto. Para que a visualização seja profissional e compreensível, devemos sempre adicionar títulos, rótulos aos eixos e, se necessário, uma grade.

- `title('Texto do Título')`: Adiciona um título ao topo do gráfico.
- `xlabel('Texto do Eixo X')`: Adiciona um rótulo ao eixo horizontal.
- `ylabel('Texto do Eixo Y')`: Adiciona um rótulo ao eixo vertical.
- `legend('Descrição da Linha 1', 'Descrição 2', ...)`: Adiciona uma legenda, essencial quando há múltiplas curvas.
- `grid on`: Adiciona uma grade de fundo para facilitar a leitura dos valores.

Podemos também personalizar a aparência da linha (cor, estilo, marcadores) através de um terceiro argumento opcional na função `plot`, uma string chamada *LineSpec*. Por exemplo, `'r--o'` criaria uma linha vermelha (`r`), tracejada (`--`) e com marcadores circulares (`o`) em cada ponto.

Vamos agora criar um gráfico completo, plotando as funções seno e cosseno juntas. Para isso, usamos o comando `hold on`, que "segura" o gráfico atual para que novos `plots` sejam adicionados a ele, em vez de substituí-lo.

```matlab
% Cria os dados
x = 0:0.1:2*pi;
y1 = sin(x);
y2 = cos(x);

% Cria uma nova figura (boa prática)
figure;

% Plota a primeira curva (seno) com uma linha azul, sólida e com marcadores '+'
plot(x, y1, 'b-+');

% "Segura" o gráfico para adicionar a próxima curva
hold on; 

% Plota a segunda curva (cosseno) com uma linha vermelha e tracejada
plot(x, y2, 'r--');

% "Solta" o gráfico
hold off;

% Adiciona os elementos de clareza
title('Funções Seno e Cosseno');
xlabel('Ângulo (radianos)');
ylabel('Valor da Função');
legend('sin(x)', 'cos(x)');
grid on;
```

## Múltiplos Gráficos em Uma Figura: `subplot`

Às vezes, queremos mostrar vários gráficos relacionados, mas em eixos separados, dentro da mesma janela. Para isso, usamos a função `subplot(m, n, p)`, que divide a janela da figura em uma grade de `m` linhas e `n` colunas, e seleciona a posição `p` (contada da esquerda para a direita, de cima para baixo) como ativa para o próximo comando `plot`.

```matlab
% Cria os dados
x = linspace(-5, 5, 100); % Cria 100 pontos entre -5 e 5

% Cria uma nova figura
figure;

% Primeiro gráfico (posição 1 de uma grade 2x2)
subplot(2, 2, 1);
plot(x, x.^2);
title('Função Quadrática (x^2)');
grid on;

% Segundo gráfico (posição 2)
subplot(2, 2, 2);
plot(x, x.^3);
title('Função Cúbica (x^3)');
grid on;

% Terceiro gráfico (posição 3)
subplot(2, 2, 3);
plot(x, sin(x));
title('Função Seno (sin(x))');
grid on;

% Quarto gráfico (posição 4)
subplot(2, 2, 4);
plot(x, exp(x));
title('Função Exponencial (e^x)');
grid on;
```

# Técnicas para Depurar (*Debugar*) Programas

Escrever código sem erros é praticamente impossível. A depuração é o processo metódico de encontrar e corrigir esses erros. Um bom programador não é aquele que não comete erros, mas aquele que sabe como encontrá-los eficientemente.

Existem, em geral, três tipos de erros:

1. **Erros de Sintaxe**: O código viola as regras da linguagem (ex: `a = (2 + 3` sem fechar o parêntese). O Editor do MATLAB geralmente sublinha esses erros em vermelho.
2. **Erros de Execução (*Runtime*)**: O código é sintaticamente válido, mas uma operação impossível ocorre durante a execução (ex: tentar acessar `matriz(5,5)` em uma matriz 4x4). O programa para e exibe uma mensagem de erro na *Command Window*.
3. **Erros Lógicos**: O tipo mais traiçoeiro. O código roda sem quebrar, mas produz um resultado incorreto devido a uma falha na lógica. É para estes que o depurador é mais útil

## O Depurador do MATLAB: *Breakpoints* e Execução Passo a Passo

A ferramenta mais poderosa para encontrar erros lógicos é o depurador integrado ao Editor do MATLAB. A ideia central é usar **breakpoints**.

Um **breakpoint** (ponto de parada) é um marcador que você coloca em uma linha do seu código. Ao executar o programa, a execução irá pausar *antes* de executar a linha marcada. Isso lhe dá a chance de inspecionar o estado do programa (os valores de todas as variáveis) naquele exato momento.

**Como usar o depurador:**

1. **Escreva seu código** em um arquivo `.m` no Editor.
2. **Defina um breakpoint**: Clique na pequena faixa cinza ao lado do número da linha onde você quer pausar. Um círculo vermelho aparecerá.
3. **Execute o programa**: Pressione o botão "Run" (ou F5). A execução começará e irá parar na linha com o breakpoint, que ficará destacada com uma seta verde.
4. **Entre no modo de depuração**: O prompt na *Command Window* mudará de `>>` para `K>>`, indicando que você está no modo de depuração (*keyboard mode*).
5. **Inspecione**: Agora você pode digitar nomes de variáveis na *Command Window* para ver seus valores atuais ou olhar o painel do *Workspace*.
6. **Controle a execução**: No topo da janela do Editor, aparecerão botões de controle:
    - **Continue (F5)**: Continua a execução normal até o próximo breakpoint ou o fim do programa.
    - **Step (F10)**: Executa **apenas a linha atual** e para na próxima. É a ferramenta mais útil para avançar o código lentamente.
    - **Step In (F11)**: Se a linha atual for uma chamada para outra função que você escreveu, este botão entra nessa função.
    - **Step Out (Shift+F11)**: Se você estiver dentro de uma função, executa o restante dela e retorna para onde ela foi chamada.
    - **Quit Debugging (Shift+F5)**: Interrompe a execução imediatamente.

**Exemplo prático de depuração:**

Imagine que este código, que deveria calcular 5!=120, está com um erro lógico.

```matlab
% Arquivo calcula_fatorial_errado.m
n = 5;
resultado = 0; % ERRO LÓGICO AQUI! Deveria ser 1.
for i = 1:n
    resultado = resultado * i;
end
fprintf('O fatorial de %d é %d\n', n, resultado);
```

O resultado impresso será 0, o que está incorreto.

**Processo de depuração:**

1. Coloque um breakpoint na linha `resultado = resultado * i;`.
2. Execute o código. Ele irá parar na primeira vez que for executar essa linha, dentro do laço `for`.
3. No prompt `K>>`, verifique os valores iniciais. Digite `i`, e o resultado será `1`. Digite `resultado`, e o resultado será `0`.
4. Pressione **Step (F10)**. A linha será executada.
5. Inspecione novamente. `resultado` agora é `0 * 1 = 0`. `i` agora é `2`.
6. Pressione **Step (F10)** de novo. `resultado` agora é `0 * 2 = 0`.
7. Neste ponto, o padrão fica claro: como `resultado` começou em 0, ele será sempre 0. O erro está na inicialização da variável.
8. Saia do modo de depuração (Shift+F5), corrija a linha para `resultado = 1;`, remova o breakpoint e execute novamente para confirmar o resultado correto.