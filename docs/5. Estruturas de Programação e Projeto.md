# Introdução: Do Cálculo à Lógica

Até agora, nossos scripts seguiram um fluxo linear: uma sequência de comandos executados um após o outro, do início ao fim. Contudo, programas verdadeiramente úteis raramente são tão simples. Eles precisam avaliar informações, tomar decisões e reagir de maneiras diferentes a entradas distintas. Em suma, eles precisam de **lógica**.

Este capítulo introduz os conceitos fundamentais do projeto de programas e as estruturas de controle que permitem ao MATLAB tomar decisões. Abordaremos técnicas para planejar seu código antes de escrevê-lo e, em seguida, mergulharemos nos tipos de dados lógicos e nas estruturas de ramificação (`if/else`) que formam a espinha dorsal da lógica de programação.

# Técnicas de Projeto de Programas (*Top-Down*) e Pseudocódigo

Antes de escrever uma única linha de código, especialmente para tarefas mais complexas, é uma prática de engenharia de software extremamente valiosa planejar a estrutura do seu programa. Uma das metodologias mais eficazes para isso é o **projeto *top-down*** (de cima para baixo).

A ideia do projeto *top-down* é começar com uma descrição de alto nível do que o programa precisa fazer e, em seguida, quebrar essa tarefa principal em subtarefas menores e mais gerenciáveis. Você continua esse processo de decomposição até que cada subtarefa seja simples o suficiente para ser implementada diretamente em código.

**Exemplo Prático: Projeto *Top-Down***

**Tarefa Principal:** Criar um programa que calcula a média das notas de um aluno e determina se ele foi aprovado.

1. **Decomposição Nível 1:**
    1. Obter as notas do aluno.
    2. Calcular a média das notas.
    3. Comparar a média com o critério de aprovação.
    4. Exibir o resultado final (média e status de aprovação).
2. **Decomposição Nível 2 (refinando cada passo):**

   1.1. Definir um vetor com as notas.

   2.1. Somar todas as notas.

   2.2. Contar o número de notas.

   2.3. Dividir a soma pelo número de notas.

   3.1. Definir a nota mínima para aprovação (ex: 7.0).

   3.2. Verificar se a média calculada é maior ou igual à nota mínima.

   4.1. Se aprovado, exibir uma mensagem de parabéns.

   4.2. Se reprovado, exibir uma mensagem de incentivo.


Essa estrutura serve como um esqueleto para o seu código. Para refinar ainda mais esse plano, usamos o **pseudocódigo.**

O **pseudocódigo** é uma forma de descrever os passos de um algoritmo usando uma linguagem informal e estruturada, que se assemelha a uma linguagem de programação, mas sem se preocupar com a sintaxe exata. É uma ponte entre a linguagem humana e o código.

**Pseudocódigo para o exemplo das notas:**

```matlab
// Início
// 1. Obter notas
   DEFINIR notas = [8.5, 9.0, 6.5, 7.5]

// 2. Calcular média
   soma_das_notas = SOMA(notas)
   numero_de_notas = CONTAR(notas)
   media = soma_das_notas / numero_de_notas

// 3. Comparar
   SE media >= 7.0 ENTÃO
       status = "Aprovado"
   SENÃO
       status = "Reprovado"
   FIM SE

// 4. Exibir resultado
   IMPRIMIR "A média final é: ", media
   IMPRIMIR "Status: ", status
// Fim
```

Usar essas técnicas pode parecer um passo extra no início, mas para programas maiores, economiza um tempo imenso de depuração e reescrita, resultando em um código mais claro, organizado e correto.

# Tipos de Dados Lógicos e Operadores Relacionais

Para que o programa possa tomar decisões, ele precisa ser capaz de avaliar expressões que resultem em **verdadeiro** ou **falso**. No MATLAB, esses valores são representados pelo tipo de dado `logical`, com os valores `true` (que é numericamente equivalente a 1) e `false` (numericamente equivalente a 0).

Para criar essas expressões lógicas, usamos os **operadores relacionais**:

| Operador | Descrição | Exemplo | Resultado |
| --- | --- | --- | --- |
| `==` | Igual a | `5 == 5` | `true` |
| `~=` | Diferente de | `5 ~= 5` | `false` |
| `>` | Maior que | `5 > 3` | `true` |
| `<` | Menor que | `5 < 3` | `false` |
| `>=` | Maior ou igual a | `5 >= 5` | `true` |
| `<=` | Menor ou igual a | `5 <= 3` | `false` |

Esses operadores são **vetorizados**, ou seja, podem ser usados para comparar matrizes inteiras (elemento a elemento), resultando em uma matriz lógica.

```matlab
A = [1 5 10];
B = [2 5 8];

resultado = A >= B; % Compara cada elemento
% resultado será uma matriz lógica: [false, true, true]
```

Para combinar múltiplas condições lógicas, usamos os **operadores lógicos**:

| Operador | Descrição (E Lógico) | Exemplo | Resultado |
| --- | --- | --- | --- |
| `&` | *Element-wise* AND | `(5 > 3) & (10 == 10)` | `true` |
| `&&` | *Short-circuit* AND | `(5 > 3) && (10 == 10)` | `true` |
| ` | ` | *Element-wise* OR (OU) | `(5 < 3) |
| ` |  | ` | *Short-circuit* OR |
| `~` | NOT (NÃO) | `~(5 == 3)` | `true` |

A diferença entre `&` e `&&` (e `|` vs `||`) é sutil, mas importante:

- Os operadores de um caractere (`&`, `|`) operam elemento a elemento em matrizes.
- Os operadores de dois caracteres (`&&`, `||`) operam apenas em escalares e usam "curto-circuito" (*short-circuiting*). Isso significa que, em `A && B`, se `A` for falso, `B` nem é avaliado, pois o resultado já é garantidamente falso. Isso é útil para evitar erros, como em `(x ~= 0) && (1/x > 5)`.

# **Estruturas de Ramificação: `if`, `elseif`, `else`**

Agora que sabemos como criar condições lógicas, podemos usá-las para controlar o fluxo do programa. A estrutura `if` é a ferramenta fundamental para isso. Sua sintaxe é:

```matlab
if condicao
    % Bloco de código a ser executado
    % SE a 'condicao' for verdadeira.
end
```

**Importante:** a estrutura sempre termina com a palavra-chave `end`.

Podemos estender essa lógica com `else`, para fornecer um caminho alternativo caso a condição seja falsa.

```matlab
if condicao
    % Bloco executado se a condição for VERDADEIRA.
else
    % Bloco executado se a condição for FALSA.
end
```

E para testar múltiplas condições em sequência, usamos `elseif`.

```matlab
if condicao_1
    % Bloco A: executado se condicao_1 for verdadeira.
elseif condicao_2
    % Bloco B: executado se condicao_1 for falsa E condicao_2 for verdadeira.
elseif condicao_3
    % Bloco C: executado se 1 e 2 forem falsas E 3 for verdadeira.
else
    % Bloco D: executado se NENHUMA das condições acima for verdadeira.
end
```

Apenas um dos blocos de código será executado.

**Vamos implementar nosso exemplo das notas em código MATLAB real:**

```matlab
% 1. Obter notas
notas = [8.5, 9.0, 6.5, 7.5];
nota_minima = 7.0;

% 2. Calcular média
media = mean(notas); % Usando a função pré-definida 'mean'

fprintf('A média final é: %.2f\n', media);

% 3. e 4. Comparar e Exibir Resultado
if media >= nota_minima
    disp('Status: Aprovado! Parabéns!');
elseif media >= 5.0 % Adicionando uma condição para recuperação
    disp('Status: Em Recuperação. Estude um pouco mais!');
else
    disp('Status: Reprovado. Não desista, você consegue na próxima!');
end
```

Este código implementa de forma limpa a lógica que planejamos, demonstrando como as estruturas de decisão são essenciais para criar programas que respondem dinamicamente aos dados.

# Recursos Adicionais para Gráficos

As estruturas de decisão também podem ser usadas para criar gráficos mais inteligentes e informativos. Por exemplo, você pode querer plotar dados de diferentes cores dependendo de um certo limiar.

```matlab
% Plota pontos em azul se y >= 0, e em vermelho se y < 0
x = linspace(-2*pi, 2*pi, 100);
y = sin(x);

figure;
hold on; % Prepara para múltiplos plots

for i = 1:length(x)
    if y(i) >= 0
        plot(x(i), y(i), 'b.'); % 'b.' plota um ponto azul
    else
        plot(x(i), y(i), 'r.'); % 'r.' plota um ponto vermelho
    end
end

title('Visualização Condicional de Dados');
grid on;
hold off;
```

Observação: Este exemplo usa um laço `for`, que será o tópico do nosso próximo capítulo. Ele serve para ilustrar como a lógica de `if/else` pode ser aplicada em um contexto de plotagem.